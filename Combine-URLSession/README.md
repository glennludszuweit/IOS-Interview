## 1. What is root class in swift
<p>In Swift, the concept of a "root class" doesn't exist in the same way as it does in some other programming languages. Unlike languages such as Objective-C, C# or Java, where all classes inherit from a common root class (e.g., NSObject or Object), Swift does not have a universal root class that all classes must inherit from.</p>
<p>Instead, in Swift, classes and structures are declared using the class and struct keywords, respectively, and they can inherit from other classes or structures using the inheritance syntax. When you don't explicitly specify a superclass for your class or structure, it doesn't implicitly inherit from any particular root class.</p>
<p>That being said, Swift does provide a set of fundamental types and protocols that are available to all types, regardless of whether they inherit from a particular class or structure. These fundamental types include types like String, Int, Bool, and protocols like Equatable and Comparable.</p>
<p>As an experienced iOS developer, I fully understand the principles of inheritance and design patterns in object-oriented programming. While Swift doesn't enforce a universal root class, you can still create your own base classes or utilize existing ones based on your project's requirements. For instance, you might define a custom base class that contains common functionality that you want to share across multiple subclasses.</p>

## 2. What is optionals?
<p>Optionals are a key feature in Swift that allow developers to express the absence of a value for a particular variable or constant. In other words, an optional variable can either have a value or have no value at all (be nil). This is in contrast to non-optional variables, which must always have a value.</p>
<p>Behind the scenes, optionals in Swift are implemented using an enumeration called Optional. This enumeration has two possible states: .none, which represents the absence of a value, and .some(value), which represents the presence of a value. When you declare an optional variable, it is either set to .none or .some(value).</p>
<p>Optionals in Swift are designed to provide safer and more concise code compared to Objective-C. In Objective-C, there are no built-in optionals, and developers often use nil to represent the absence of a value. However, this can lead to runtime crashes if you mistakenly access a variable that is nil. In Swift, optionals help prevent these runtime crashes by forcing you to explicitly handle the case where a variable might be nil.</p>
<p>To consume an optional in Swift, you typically use optional binding or optional chaining. Optional binding allows you to check if an optional has a value and, if so, unwrap it into a non-optional variable. Optional chaining provides a way to access properties and call methods on an optional variable, while gracefully handling the case where the variable is nil.</p>

<p>Optionals are used in Swift for several reasons:</p>

- **Safety:** Optionals help catch and prevent runtime crashes by explicitly handling the absence of a value. This encourages developers to write more robust and error-resistant code.
- **Clarity:** By using optionals, you make it clear in your code that a variable or constant might be nil, making the absence of a value more explicit and reducing ambiguity.
- **Swift API design:** The Swift standard library and many third-party libraries use optionals extensively, allowing developers to interact with APIs that may or may not return a value.
- **Optionals as return types:** Optionals are commonly used as return types for functions or methods that may not always produce a result. This way, the caller can easily handle the case where no value is returned.

## 3. Different initialisers
- **Default Initializer** is the basic initializer that sets default values for all properties. It's automatically generated by the compiler if no other initializers are defined. Use it when you want to create an instance with default property values.
- **Memberwise initializers** initialize the properties of a struct with individual parameters for each property. It's useful when you have a struct with multiple properties and want to provide a convenient way to initialize them.
- **Custom initializers** are defined by the developer to provide specific initialization logic. Use them when you need to perform additional setup or customization beyond what the default or memberwise initializers offer.
- **Required initializers** are used in protocol definitions. They indicate that any class conforming to that protocol must implement this initializer. Use them to ensure that certain properties or setup steps are provided by conforming types.

## 4. Class vs struct
**Inheritance:**
- Classes support inheritance, allowing one class to inherit properties and methods from another. This enables the creation of hierarchical relationships and promotes code reuse.
- Structs do not support inheritance. They are value types and cannot inherit from other structs or classes.

**Mutability:**
- Class instances are mutable by default, meaning their properties can be modified even after initialization.
- Struct instances are immutable by default. Once a struct instance is created, its properties cannot be changed. If you need to modify a struct's properties, you must create a new instance.

**Reference vs Value type:**
- Classes are reference types. When you assign a class instance to a new variable or pass it as a parameter, you are working with a reference to the original instance. Modifying the reference will affect the original object.
- Structs are value types. When you assign a struct instance to a new variable or pass it as a parameter, a copy of the original instance is created. Modifying the copy does not affect the original struct.

**Memory management:**
- Classes use reference counting to manage memory. When there are no more references to a class instance, it is automatically deallocated.
- Structs are allocated on the stack or as part of other value types, and memory management is handled automatically.

**Usage and performance:**
- Classes are generally used for complex data models, objects with shared state, and when inheritance or reference semantics are required.
- Structs are commonly used for small data structures, lightweight objects, and when value semantics and immutability are desirable. They are often more performant than classes due to stack allocation and copying semantics.

## 5. How do you write tests
<p>The main focus is testing a single behavior or functionality of the code. Keeping tests focused and granular makes them easier to understand, maintain, and debug. This can be easily applied if the codebase follows the Single Responsibility Principle (SRP).</p>
<p>When testing units of code that have dependencies on external resources or services, I use mocking or stubbing techniques to isolate the code under test. Mocking allows me to create fake objects or services that simulate the behavior of the real dependencies, enabling me to control the test environment and make the tests more deterministic. Dependency injection facilitates the ability to swap out real dependencies with mocks or stubs during testing. This can be easily achieved if the codebase follows Protocol Oriented Programing.</p>
<p>Aiming for high test coverage to ensure that the tests adequately exercise all parts of the codebase. I Use code coverage tools to measure the percentage of code covered by your tests. Additionally, I would integrate tests into a continuous integration (CI) system to automatically run tests whenever changes are made to the codebase. This helps catch issues early and ensures that tests are regularly executed in a controlled environment.</p>

## 6. Different App States
- **Not Running:** The app is not running or has been terminated by the user or the system.
- **Inactive:** The app is running in the foreground but is not receiving events. This state occurs briefly during transitions, such as when a call or message arrives or when the user switches to another app.
- **Active:** The app is running in the foreground and is receiving events. This is the normal state when the user is interacting with the app.
- **Background:** The app is in the background and executing code. It may be performing tasks such as playing audio, updating location information, or downloading data. Most apps enter this state when the user switches to another app.
- **Suspended:** The app is in the background but is not executing code. The system may purge suspended apps from memory to reclaim resources. When the user returns to the app, it typically transitions to the inactive state before becoming active.

## 7. Escaping vs non escaping
- **Non-escaping** closures are closures that are executed synchronously and do not persist beyond the lifetime of the function or method that they are passed into. They are typically used for short-lived operations.

- **Escaping closures**, on the other hand, outlive the function or method that they are passed into. They are typically used when the closure needs to be executed asynchronously at a later time, such as when performing network requests or animations.

# Live coding 
## GIVEN below url , call this using URLSession using combine and show list of products using SwiftUI. https://dummyjson.com/products
